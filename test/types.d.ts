// GENERATED CODE - DO NOT MODIFY BY HAND
type _TygojaDict = { [key:string | number | symbol]: any; }
type _TygojaAny = any
declare var $app: c.Handler;
namespace c {
  interface Handler {(): string  }
  interface Example2 {
    Title: string
  }
  interface Example2 {
    DemoEx2(): time.Time
  }
}

/**
 * package a docs
 * lorem ipsum dolor...
 */
namespace a {
  interface Empty {
  }
  interface interfaceA<T> {
    /**
     * some comment
     */
    /**
     * some comment above the function
     */
    Method0(): void
    Method1(): string // inline comment
    /**
     * multi
     * line
     * comment
     */
    Method2(argA: string): [T, number]
    Method3(argA: number, ...argB: string[]): [T, Array<string>]
  }
  interface InterfaceB {
    /**
     * "replace" Method0 from interfaceA
     */
    Method0(): void
    CustomMethod(): time.Time
  }
  interface unexported {
    Field1: string
  }
  interface structA {
    Field1: string // after
    /**
     * multi
     * line
     * comment
     */
    Field2: string
  }
  interface structA {
    /**
     * method comment
     */
    Method1(arg1: number): void
  }
  interface structA {
    Method2(arg1: number, ...arg2: string[]): void
  }
  type _subWTSqu = unexported&structA
  interface StructB<T> extends _subWTSqu {
    Field3: T
  }
  interface StructB<T> {
    Method3(arg1: number): [number, string]
  }
  interface SliceAlias<T> extends Array<T>{} // after
  interface Handler<T> {(): [T, number]  } // after
}

/**
 * package b
 */
namespace b {
  interface Func1 {
    /**
     * single comment
     */
    (): void
  }
  interface Func2<T> {
    /**
     * multi
     * line
     * comment
     */
    (arg1: number): T
  }
}

/**
 * Package time provides functionality for measuring and displaying time.
 * 
 * The calendrical calculations always assume a Gregorian calendar, with
 * no leap seconds.
 * 
 * # Monotonic Clocks
 * 
 * Operating systems provide both a “wall clock,” which is subject to
 * changes for clock synchronization, and a “monotonic clock,” which is
 * not. The general rule is that the wall clock is for telling time and
 * the monotonic clock is for measuring time. Rather than split the API,
 * in this package the Time returned by time.Now contains both a wall
 * clock reading and a monotonic clock reading; later time-telling
 * operations use the wall clock reading, but later time-measuring
 * operations, specifically comparisons and subtractions, use the
 * monotonic clock reading.
 * 
 * For example, this code always computes a positive elapsed time of
 * approximately 20 milliseconds, even if the wall clock is changed during
 * the operation being timed:
 * 
 * ```
 * 	start := time.Now()
 * 	... operation that takes 20 milliseconds ...
 * 	t := time.Now()
 * 	elapsed := t.Sub(start)
 * ```
 * 
 * Other idioms, such as time.Since(start), time.Until(deadline), and
 * time.Now().Before(deadline), are similarly robust against wall clock
 * resets.
 * 
 * The rest of this section gives the precise details of how operations
 * use monotonic clocks, but understanding those details is not required
 * to use this package.
 * 
 * The Time returned by time.Now contains a monotonic clock reading.
 * If Time t has a monotonic clock reading, t.Add adds the same duration to
 * both the wall clock and monotonic clock readings to compute the result.
 * Because t.AddDate(y, m, d), t.Round(d), and t.Truncate(d) are wall time
 * computations, they always strip any monotonic clock reading from their results.
 * Because t.In, t.Local, and t.UTC are used for their effect on the interpretation
 * of the wall time, they also strip any monotonic clock reading from their results.
 * The canonical way to strip a monotonic clock reading is to use t = t.Round(0).
 * 
 * If Times t and u both contain monotonic clock readings, the operations
 * t.After(u), t.Before(u), t.Equal(u), and t.Sub(u) are carried out
 * using the monotonic clock readings alone, ignoring the wall clock
 * readings. If either t or u contains no monotonic clock reading, these
 * operations fall back to using the wall clock readings.
 * 
 * On some systems the monotonic clock will stop if the computer goes to sleep.
 * On such a system, t.Sub(u) may not accurately reflect the actual
 * time that passed between t and u.
 * 
 * Because the monotonic clock reading has no meaning outside
 * the current process, the serialized forms generated by t.GobEncode,
 * t.MarshalBinary, t.MarshalJSON, and t.MarshalText omit the monotonic
 * clock reading, and t.Format provides no format for it. Similarly, the
 * constructors time.Date, time.Parse, time.ParseInLocation, and time.Unix,
 * as well as the unmarshalers t.GobDecode, t.UnmarshalBinary.
 * t.UnmarshalJSON, and t.UnmarshalText always create times with
 * no monotonic clock reading.
 * 
 * The monotonic clock reading exists only in Time values. It is not
 * a part of Duration values or the Unix times returned by t.Unix and
 * friends.
 * 
 * Note that the Go == operator compares not just the time instant but
 * also the Location and the monotonic clock reading. See the
 * documentation for the Time type for a discussion of equality
 * testing for Time values.
 * 
 * For debugging, the result of t.String does include the monotonic
 * clock reading if present. If t != u because of different monotonic clock readings,
 * that difference will be visible when printing t.String() and u.String().
 */
namespace time {
  interface Time {
    /**
     * String returns the time formatted using the format string
     * 
     * ```
     * 	"2006-01-02 15:04:05.999999999 -0700 MST"
     * ```
     * 
     * If the time has a monotonic clock reading, the returned string
     * includes a final field "m=±<value>", where value is the monotonic
     * clock reading formatted as a decimal number of seconds.
     * 
     * The returned string is meant for debugging; for a stable serialized
     * representation, use t.MarshalText, t.MarshalBinary, or t.Format
     * with an explicit format string.
     */
    String(): string
  }
  interface Time {
    /**
     * GoString implements fmt.GoStringer and formats t to be printed in Go source
     * code.
     */
    GoString(): string
  }
  interface Time {
    /**
     * Format returns a textual representation of the time value formatted according
     * to the layout defined by the argument. See the documentation for the
     * constant called Layout to see how to represent the layout format.
     * 
     * The executable example for Time.Format demonstrates the working
     * of the layout string in detail and is a good reference.
     */
    Format(layout: string): string
  }
  interface Time {
    /**
     * AppendFormat is like Format but appends the textual
     * representation to b and returns the extended buffer.
     */
    AppendFormat(b: string, layout: string): string
  }
  interface Time {
  }
  interface Time {
    /**
     * After reports whether the time instant t is after u.
     */
    After(u: Time): boolean
  }
  interface Time {
    /**
     * Before reports whether the time instant t is before u.
     */
    Before(u: Time): boolean
  }
  interface Time {
    /**
     * Equal reports whether t and u represent the same time instant.
     * Two times can be equal even if they are in different locations.
     * For example, 6:00 +0200 and 4:00 UTC are Equal.
     * See the documentation on the Time type for the pitfalls of using == with
     * Time values; most code should use Equal instead.
     */
    Equal(u: Time): boolean
  }
  interface Time {
    /**
     * IsZero reports whether t represents the zero time instant,
     * January 1, year 1, 00:00:00 UTC.
     */
    IsZero(): boolean
  }
  interface Time {
    /**
     * Date returns the year, month, and day in which t occurs.
     */
    Date(): [number, Month, number]
  }
  interface Time {
    /**
     * Year returns the year in which t occurs.
     */
    Year(): number
  }
  interface Time {
    /**
     * Month returns the month of the year specified by t.
     */
    Month(): Month
  }
  interface Time {
    /**
     * Day returns the day of the month specified by t.
     */
    Day(): number
  }
  interface Time {
    /**
     * Weekday returns the day of the week specified by t.
     */
    Weekday(): Weekday
  }
  interface Time {
    /**
     * ISOWeek returns the ISO 8601 year and week number in which t occurs.
     * Week ranges from 1 to 53. Jan 01 to Jan 03 of year n might belong to
     * week 52 or 53 of year n-1, and Dec 29 to Dec 31 might belong to week 1
     * of year n+1.
     */
    ISOWeek(): number
  }
  interface Time {
    /**
     * Clock returns the hour, minute, and second within the day specified by t.
     */
    Clock(): number
  }
  interface Time {
    /**
     * Hour returns the hour within the day specified by t, in the range [0, 23].
     */
    Hour(): number
  }
  interface Time {
    /**
     * Minute returns the minute offset within the hour specified by t, in the range [0, 59].
     */
    Minute(): number
  }
  interface Time {
    /**
     * Second returns the second offset within the minute specified by t, in the range [0, 59].
     */
    Second(): number
  }
  interface Time {
    /**
     * Nanosecond returns the nanosecond offset within the second specified by t,
     * in the range [0, 999999999].
     */
    Nanosecond(): number
  }
  interface Time {
    /**
     * YearDay returns the day of the year specified by t, in the range [1,365] for non-leap years,
     * and [1,366] in leap years.
     */
    YearDay(): number
  }
  interface Time {
    /**
     * Add returns the time t+d.
     */
    Add(d: Duration): Time
  }
  interface Time {
    /**
     * Sub returns the duration t-u. If the result exceeds the maximum (or minimum)
     * value that can be stored in a Duration, the maximum (or minimum) duration
     * will be returned.
     * To compute t-d for a duration d, use t.Add(-d).
     */
    Sub(u: Time): Duration
  }
  interface Time {
    /**
     * AddDate returns the time corresponding to adding the
     * given number of years, months, and days to t.
     * For example, AddDate(-1, 2, 3) applied to January 1, 2011
     * returns March 4, 2010.
     * 
     * AddDate normalizes its result in the same way that Date does,
     * so, for example, adding one month to October 31 yields
     * December 1, the normalized form for November 31.
     */
    AddDate(years: number, months: number, days: number): Time
  }
  interface Time {
    /**
     * UTC returns t with the location set to UTC.
     */
    UTC(): Time
  }
  interface Time {
    /**
     * Local returns t with the location set to local time.
     */
    Local(): Time
  }
  interface Time {
    /**
     * In returns a copy of t representing the same time instant, but
     * with the copy's location information set to loc for display
     * purposes.
     * 
     * In panics if loc is nil.
     */
    In(loc: Location): Time
  }
  interface Time {
    /**
     * Location returns the time zone information associated with t.
     */
    Location(): (Location | undefined)
  }
  interface Time {
    /**
     * Zone computes the time zone in effect at time t, returning the abbreviated
     * name of the zone (such as "CET") and its offset in seconds east of UTC.
     */
    Zone(): [string, number]
  }
  interface Time {
    /**
     * ZoneBounds returns the bounds of the time zone in effect at time t.
     * The zone begins at start and the next zone begins at end.
     * If the zone begins at the beginning of time, start will be returned as a zero Time.
     * If the zone goes on forever, end will be returned as a zero Time.
     * The Location of the returned times will be the same as t.
     */
    ZoneBounds(): Time
  }
  interface Time {
    /**
     * Unix returns t as a Unix time, the number of seconds elapsed
     * since January 1, 1970 UTC. The result does not depend on the
     * location associated with t.
     * Unix-like operating systems often record time as a 32-bit
     * count of seconds, but since the method here returns a 64-bit
     * value it is valid for billions of years into the past or future.
     */
    Unix(): number
  }
  interface Time {
    /**
     * UnixMilli returns t as a Unix time, the number of milliseconds elapsed since
     * January 1, 1970 UTC. The result is undefined if the Unix time in
     * milliseconds cannot be represented by an int64 (a date more than 292 million
     * years before or after 1970). The result does not depend on the
     * location associated with t.
     */
    UnixMilli(): number
  }
  interface Time {
    /**
     * UnixMicro returns t as a Unix time, the number of microseconds elapsed since
     * January 1, 1970 UTC. The result is undefined if the Unix time in
     * microseconds cannot be represented by an int64 (a date before year -290307 or
     * after year 294246). The result does not depend on the location associated
     * with t.
     */
    UnixMicro(): number
  }
  interface Time {
    /**
     * UnixNano returns t as a Unix time, the number of nanoseconds elapsed
     * since January 1, 1970 UTC. The result is undefined if the Unix time
     * in nanoseconds cannot be represented by an int64 (a date before the year
     * 1678 or after 2262). Note that this means the result of calling UnixNano
     * on the zero Time is undefined. The result does not depend on the
     * location associated with t.
     */
    UnixNano(): number
  }
  interface Time {
    /**
     * MarshalBinary implements the encoding.BinaryMarshaler interface.
     */
    MarshalBinary(): string
  }
  interface Time {
    /**
     * UnmarshalBinary implements the encoding.BinaryUnmarshaler interface.
     */
    UnmarshalBinary(data: string): void
  }
  interface Time {
    /**
     * GobEncode implements the gob.GobEncoder interface.
     */
    GobEncode(): string
  }
  interface Time {
    /**
     * GobDecode implements the gob.GobDecoder interface.
     */
    GobDecode(data: string): void
  }
  interface Time {
    /**
     * MarshalJSON implements the json.Marshaler interface.
     * The time is a quoted string in RFC 3339 format, with sub-second precision added if present.
     */
    MarshalJSON(): string
  }
  interface Time {
    /**
     * UnmarshalJSON implements the json.Unmarshaler interface.
     * The time is expected to be a quoted string in RFC 3339 format.
     */
    UnmarshalJSON(data: string): void
  }
  interface Time {
    /**
     * MarshalText implements the encoding.TextMarshaler interface.
     * The time is formatted in RFC 3339 format, with sub-second precision added if present.
     */
    MarshalText(): string
  }
  interface Time {
    /**
     * UnmarshalText implements the encoding.TextUnmarshaler interface.
     * The time is expected to be in RFC 3339 format.
     */
    UnmarshalText(data: string): void
  }
  interface Time {
    /**
     * IsDST reports whether the time in the configured location is in Daylight Savings Time.
     */
    IsDST(): boolean
  }
  interface Time {
    /**
     * Truncate returns the result of rounding t down to a multiple of d (since the zero time).
     * If d <= 0, Truncate returns t stripped of any monotonic clock reading but otherwise unchanged.
     * 
     * Truncate operates on the time as an absolute duration since the
     * zero time; it does not operate on the presentation form of the
     * time. Thus, Truncate(Hour) may return a time with a non-zero
     * minute, depending on the time's Location.
     */
    Truncate(d: Duration): Time
  }
  interface Time {
    /**
     * Round returns the result of rounding t to the nearest multiple of d (since the zero time).
     * The rounding behavior for halfway values is to round up.
     * If d <= 0, Round returns t stripped of any monotonic clock reading but otherwise unchanged.
     * 
     * Round operates on the time as an absolute duration since the
     * zero time; it does not operate on the presentation form of the
     * time. Thus, Round(Hour) may return a time with a non-zero
     * minute, depending on the time's Location.
     */
    Round(d: Duration): Time
  }
}

/**
 * Package time provides functionality for measuring and displaying time.
 * 
 * The calendrical calculations always assume a Gregorian calendar, with
 * no leap seconds.
 * 
 * # Monotonic Clocks
 * 
 * Operating systems provide both a “wall clock,” which is subject to
 * changes for clock synchronization, and a “monotonic clock,” which is
 * not. The general rule is that the wall clock is for telling time and
 * the monotonic clock is for measuring time. Rather than split the API,
 * in this package the Time returned by time.Now contains both a wall
 * clock reading and a monotonic clock reading; later time-telling
 * operations use the wall clock reading, but later time-measuring
 * operations, specifically comparisons and subtractions, use the
 * monotonic clock reading.
 * 
 * For example, this code always computes a positive elapsed time of
 * approximately 20 milliseconds, even if the wall clock is changed during
 * the operation being timed:
 * 
 * ```
 * 	start := time.Now()
 * 	... operation that takes 20 milliseconds ...
 * 	t := time.Now()
 * 	elapsed := t.Sub(start)
 * ```
 * 
 * Other idioms, such as time.Since(start), time.Until(deadline), and
 * time.Now().Before(deadline), are similarly robust against wall clock
 * resets.
 * 
 * The rest of this section gives the precise details of how operations
 * use monotonic clocks, but understanding those details is not required
 * to use this package.
 * 
 * The Time returned by time.Now contains a monotonic clock reading.
 * If Time t has a monotonic clock reading, t.Add adds the same duration to
 * both the wall clock and monotonic clock readings to compute the result.
 * Because t.AddDate(y, m, d), t.Round(d), and t.Truncate(d) are wall time
 * computations, they always strip any monotonic clock reading from their results.
 * Because t.In, t.Local, and t.UTC are used for their effect on the interpretation
 * of the wall time, they also strip any monotonic clock reading from their results.
 * The canonical way to strip a monotonic clock reading is to use t = t.Round(0).
 * 
 * If Times t and u both contain monotonic clock readings, the operations
 * t.After(u), t.Before(u), t.Equal(u), and t.Sub(u) are carried out
 * using the monotonic clock readings alone, ignoring the wall clock
 * readings. If either t or u contains no monotonic clock reading, these
 * operations fall back to using the wall clock readings.
 * 
 * On some systems the monotonic clock will stop if the computer goes to sleep.
 * On such a system, t.Sub(u) may not accurately reflect the actual
 * time that passed between t and u.
 * 
 * Because the monotonic clock reading has no meaning outside
 * the current process, the serialized forms generated by t.GobEncode,
 * t.MarshalBinary, t.MarshalJSON, and t.MarshalText omit the monotonic
 * clock reading, and t.Format provides no format for it. Similarly, the
 * constructors time.Date, time.Parse, time.ParseInLocation, and time.Unix,
 * as well as the unmarshalers t.GobDecode, t.UnmarshalBinary.
 * t.UnmarshalJSON, and t.UnmarshalText always create times with
 * no monotonic clock reading.
 * 
 * The monotonic clock reading exists only in Time values. It is not
 * a part of Duration values or the Unix times returned by t.Unix and
 * friends.
 * 
 * Note that the Go == operator compares not just the time instant but
 * also the Location and the monotonic clock reading. See the
 * documentation for the Time type for a discussion of equality
 * testing for Time values.
 * 
 * For debugging, the result of t.String does include the monotonic
 * clock reading if present. If t != u because of different monotonic clock readings,
 * that difference will be visible when printing t.String() and u.String().
 */
namespace time {
  interface Month extends Number{}
  interface Month {
    /**
     * String returns the English name of the month ("January", "February", ...).
     */
    String(): string
  }
  interface Weekday extends Number{}
  interface Weekday {
    /**
     * String returns the English name of the day ("Sunday", "Monday", ...).
     */
    String(): string
  }
  interface Duration extends Number{}
  interface Duration {
    /**
     * String returns a string representing the duration in the form "72h3m0.5s".
     * Leading zero units are omitted. As a special case, durations less than one
     * second format use a smaller unit (milli-, micro-, or nanoseconds) to ensure
     * that the leading digit is non-zero. The zero duration formats as 0s.
     */
    String(): string
  }
  interface Duration {
    /**
     * Nanoseconds returns the duration as an integer nanosecond count.
     */
    Nanoseconds(): number
  }
  interface Duration {
    /**
     * Microseconds returns the duration as an integer microsecond count.
     */
    Microseconds(): number
  }
  interface Duration {
    /**
     * Milliseconds returns the duration as an integer millisecond count.
     */
    Milliseconds(): number
  }
  interface Duration {
    /**
     * Seconds returns the duration as a floating point number of seconds.
     */
    Seconds(): number
  }
  interface Duration {
    /**
     * Minutes returns the duration as a floating point number of minutes.
     */
    Minutes(): number
  }
  interface Duration {
    /**
     * Hours returns the duration as a floating point number of hours.
     */
    Hours(): number
  }
  interface Duration {
    /**
     * Truncate returns the result of rounding d toward zero to a multiple of m.
     * If m <= 0, Truncate returns d unchanged.
     */
    Truncate(m: Duration): Duration
  }
  interface Duration {
    /**
     * Round returns the result of rounding d to the nearest multiple of m.
     * The rounding behavior for halfway values is to round away from zero.
     * If the result exceeds the maximum (or minimum)
     * value that can be stored in a Duration,
     * Round returns the maximum (or minimum) duration.
     * If m <= 0, Round returns d unchanged.
     */
    Round(m: Duration): Duration
  }
  interface Duration {
    /**
     * Abs returns the absolute value of d.
     * As a special case, math.MinInt64 is converted to math.MaxInt64.
     */
    Abs(): Duration
  }
  interface Location {
  }
  interface Location {
    /**
     * String returns a descriptive name for the time zone information,
     * corresponding to the name argument to LoadLocation or FixedZone.
     */
    String(): string
  }
}
